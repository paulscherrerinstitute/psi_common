------------------------------------------------------------
-- Copyright (c) 2020 by Paul Scherrer Institute, Switzerland
-- All rights reserved.
------------------------------------------------------------

------------------------------------------------------------
-- Testbench generated by TbGen.py
------------------------------------------------------------
-- see Library/Python/TbGenerator

------------------------------------------------------------
-- Libraries
------------------------------------------------------------
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;
	use ieee.math_real.all;

library work;
  use work.psi_common_array_pkg.all;
	use work.psi_common_math_pkg.all;
	use work.psi_common_logic_pkg.all;
  use work.psi_tb_activity_pkg.all;
  use work.psi_tb_compare_pkg.all;

------------------------------------------------------------
-- Entity Declaration
------------------------------------------------------------
entity psi_common_dyn_sft_tb is
	generic (
		direction_g : string := "LEFT" ;
		sel_bit_per_stage_g : positive := 4 ;
		sign_extend_g : boolean := true 
	);
end entity;

------------------------------------------------------------
-- Architecture
------------------------------------------------------------
architecture sim of psi_common_dyn_sft_tb is
	-- *** Fixed Generics ***
	constant max_shift_g : positive := 20;
	constant width_g : positive := 32;
	
	-- *** Not Assigned Generics (default values) ***
	
	-- *** TB Control ***
	signal TbRunning : boolean := True;
	signal NextCase : integer := -1;
	signal ProcessDone : std_logic_vector(0 to 1) := (others => '0');
	constant AllProcessesDone_c : std_logic_vector(0 to 1) := (others => '1');
	constant TbProcNr_inp_c : integer := 0;
	constant TbProcNr_outp_c : integer := 1;
	
	-- *** DUT Signals ***
	signal clk_i : std_logic := '1';
	signal rst_i : std_logic := '1';
	signal vld_i : std_logic := '0';
	signal shift_i : std_logic_vector(log2ceil(max_shift_g+1)-1 downto 0) := (others => '0');
	signal dat_i : std_logic_vector(width_g-1 downto 0) := (others => '0');
	signal vld_o : std_logic := '0';
	signal dat_o : std_logic_vector(width_g-1 downto 0) := (others => '0');
  
  constant ClkPerSpl_c    : integer := 1;
  type Random_a is array (natural range <>) of std_logic_vector(31 downto 0);
  constant Random_c : Random_a(0 to 3) := (X"ABCD1234", X"A1B2C3D4", X"12345678", X"87654321");
  constant Shift_c : t_ainteger(0 to 3) := (0, 10, 12, 20); 
	
begin
	------------------------------------------------------------
	-- DUT Instantiation
	------------------------------------------------------------
	i_dut : entity work.psi_common_dyn_sft
		generic map (
			direction_g => direction_g,
			sel_bit_per_stage_g => sel_bit_per_stage_g,
			sign_extend_g => sign_extend_g,
			max_shift_g => max_shift_g,
			width_g => width_g
		)
		port map (
			clk_i => clk_i,
			rst_i => rst_i,
			vld_i => vld_i,
			shift_i => shift_i,
			dat_i => dat_i,
			vld_o => vld_o,
			dat_o => dat_o
		);
	
	------------------------------------------------------------
	-- Testbench Control !DO NOT EDIT!
	------------------------------------------------------------
	p_tb_control : process
	begin
		wait until rst_i = '0';
		wait until ProcessDone = AllProcessesDone_c;
		TbRunning <= false;
		wait;
	end process;
	
	------------------------------------------------------------
	-- Clocks !DO NOT EDIT!
	------------------------------------------------------------
	p_clock_Clk : process
		constant Frequency_c : real := real(100e6);
	begin
		while TbRunning loop
			wait for 0.5*(1 sec)/Frequency_c;
			clk_i <= not clk_i;
		end loop;
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Resets
	------------------------------------------------------------
	p_rst_Rst : process
	begin
		wait for 1 us;
		-- Wait for two clk edges to ensure reset is active for at least one edge
		wait until rising_edge(clk_i);
		wait until rising_edge(clk_i);
		rst_i <= '0';
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Processes
	------------------------------------------------------------
	-- *** inp ***
	p_inp : process
	begin
		-- start of process !DO NOT EDIT
		wait until rst_i = '0';
		
		-- User Code
		wait until rising_edge(clk_i);
    
    for si in Shift_c'low to Shift_c'high loop
      -- Moving ones
      for i in 0 to width_g-1 loop
        dat_i    <= (others => '0');
        dat_i(i) <= '1';
        shift_i   <= to_uslv(Shift_c(si), shift_i'length);
        vld_i     <= '1';
        wait until rising_edge(clk_i);
        if ClkPerSpl_c > 1 then
          vld_i     <= '0';
          shift_i   <= (others => '0');
          WaitClockCycles(ClkPerSpl_c-1, clk_i);
        end if;
      end loop;
      
      -- Random numbers
      for i in Random_c'low to Random_c'high loop
        dat_i    <= Random_c(i);
        vld_i     <= '1';
        shift_i   <= to_uslv(Shift_c(si), shift_i'length);
        wait until rising_edge(clk_i);
        if ClkPerSpl_c > 1 then
          vld_i     <= '0';
          shift_i   <= (others => '0');
          WaitClockCycles(ClkPerSpl_c-1, clk_i);
        end if;  
      end loop;
    end loop;
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_inp_c) <= '1';
		wait;
	end process;
	
	-- *** outp ***
	p_outp : process
    variable InData_v : std_logic_vector(31 downto 0);
    variable Shift_v : integer;
	begin
		-- start of process !DO NOT EDIT
		wait until rst_i = '0';
		
    for si in Shift_c'low to Shift_c'high loop
      Shift_v := Shift_c(si);
      -- Moving ones
      for i in 0 to width_g-1 loop
        InData_v    := (others => '0');
        InData_v(i) := '1';
        wait until rising_edge(clk_i) and vld_o = '1';
        if direction_g = "LEFT" then
          StdlvCompareStdlv(shift_left(InData_v, Shift_v, '0'), dat_o, "Wrong Data: SFT=" & to_string(Shift_v) & " IN=" & to_string(InData_v));
        elsif sign_extend_g then
          StdlvCompareStdlv(shift_right(InData_v, Shift_v, InData_v(InData_v'high)), dat_o, "Wrong Data: SFT=" & to_string(Shift_v) & " IN=" & to_string(InData_v));
        else 
          StdlvCompareStdlv(shift_right(InData_v, Shift_v, '0'), dat_o, "Wrong Data: SFT=" & to_string(Shift_v) & " IN=" & to_string(InData_v));
        end if;
      end loop;
      
      -- Random numbers
      for i in Random_c'low to Random_c'high loop
        InData_v    := Random_c(i);
        wait until rising_edge(clk_i) and vld_o = '1';
        if direction_g = "LEFT" then
          StdlvCompareStdlv(shift_left(InData_v, Shift_v, '0'), dat_o, "Wrong Data: SFT=" & to_string(Shift_v) & " IN=" & to_string(InData_v));
        elsif sign_extend_g then
          StdlvCompareStdlv(shift_right(InData_v, Shift_v, InData_v(InData_v'high)), dat_o, "Wrong Data: SFT=" & to_string(Shift_v) & " IN=" & to_string(InData_v));
        else 
          StdlvCompareStdlv(shift_right(InData_v, Shift_v, '0'), dat_o, "Wrong Data: SFT=" & to_string(Shift_v) & " IN=" & to_string(InData_v));
        end if;
      end loop;
    end loop;
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_outp_c) <= '1';
		wait;
	end process;
	
	
end;
