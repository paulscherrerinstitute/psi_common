------------------------------------------------------------
-- Copyright (c) 2019 by Paul Scherrer Institute, Switzerland
-- All rights reserved.
------------------------------------------------------------

------------------------------------------------------------
-- Testbench generated by TbGen.py
------------------------------------------------------------
-- see Library/Python/TbGenerator

------------------------------------------------------------
-- Libraries
------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.psi_common_math_pkg.all;
use work.psi_tb_compare_pkg.all;

------------------------------------------------------------
-- Entity Declaration
------------------------------------------------------------
entity psi_common_tdp_ram_be_tb is
end entity;

------------------------------------------------------------
-- Architecture
------------------------------------------------------------
architecture sim of psi_common_tdp_ram_be_tb is
  -- *** Fixed Generics ***

  -- *** Not Assigned Generics (default values) ***
  constant depth_g    : positive := 4096;
  constant width_g    : positive := 32;
  constant behavior_g : string   := "RBW";

  -- *** TB Control ***
  signal TbRunning            : boolean                  := True;
  signal NextCase             : integer                  := -1;
  signal ProcessDone          : std_logic_vector(0 to 0) := (others => '0');
  constant AllProcessesDone_c : std_logic_vector(0 to 0) := (others => '1');
  constant TbProcNr_Stimuli_c : integer                  := 0;

  -- *** DUT Signals ***
  signal a_clk_i  : std_logic                                        := '1';
  signal a_addr_i : std_logic_vector(log2ceil(depth_g) - 1 downto 0) := (others => '0');
  signal a_be_i   : std_logic_vector(width_g / 8 - 1 downto 0)       := (others => '0');
  signal a_wr_i   : std_logic                                        := '0';
  signal a_dat_i  : std_logic_vector(width_g - 1 downto 0)           := (others => '0');
  signal a_dat_o : std_logic_vector(width_g - 1 downto 0)           := (others => '0');
  signal b_clk_i  : std_logic                                        := '1';
  signal b_addr_i : std_logic_vector(log2ceil(depth_g) - 1 downto 0) := (others => '0');
  signal b_be_i   : std_logic_vector(width_g / 8 - 1 downto 0)       := (others => '0');
  signal b_wr_i   : std_logic                                        := '0';
  signal b_dat_i  : std_logic_vector(width_g - 1 downto 0)           := (others => '0');
  signal b_dat_o : std_logic_vector(width_g - 1 downto 0)           := (others => '0');

begin
  ------------------------------------------------------------
  -- DUT Instantiation
  ------------------------------------------------------------
  i_dut : entity work.psi_common_tdp_ram_be
    generic map(
      depth_g    => depth_g,
      width_g    => width_g,
      behavior_g => behavior_g
    )
    port map(
      a_clk_i  => a_clk_i,
      a_addr_i => a_addr_i,
      a_be_i   => a_be_i,
      a_wr_i   => a_wr_i,
      a_dat_i  => a_dat_i,
      a_dat_o => a_dat_o,
      b_clk_i  => b_clk_i,
      b_addr_i => b_addr_i,
      b_be_i   => b_be_i,
      b_wr_i   => b_wr_i,
      b_dat_i  => b_dat_i,
      b_dat_o => b_dat_o
    );

  ------------------------------------------------------------
  -- Testbench Control !DO NOT EDIT!
  ------------------------------------------------------------
  p_tb_control : process
  begin
    wait until ProcessDone = AllProcessesDone_c;
    TbRunning <= false;
    wait;
  end process;

  ------------------------------------------------------------
  -- Clocks !DO NOT EDIT!
  ------------------------------------------------------------
  p_clock_ClkA : process
    constant Frequency_c : real := real(180e6);
  begin
    while TbRunning loop
      wait for 0.5 * (1 sec) / Frequency_c;
      a_clk_i <= not a_clk_i;
    end loop;
    wait;
  end process;

  p_clock_ClkB : process
    constant Frequency_c : real := real(25e6);
  begin
    while TbRunning loop
      wait for 0.5 * (1 sec) / Frequency_c;
      b_clk_i <= not b_clk_i;
    end loop;
    wait;
  end process;

  ------------------------------------------------------------
  -- Resets
  ------------------------------------------------------------

  ------------------------------------------------------------
  -- Processes
  ------------------------------------------------------------
  -- *** Stimuli ***
  p_Stimuli : process
  begin
    -- Delay a few clock cycles
    for i in 0 to 99 loop
      wait until falling_edge(a_clk_i);
    end loop;

    -- Write from portA
    wait until falling_edge(a_clk_i);
    a_wr_i   <= '1';
    a_be_i   <= "1111";
    a_addr_i <= X"000";
    a_dat_i  <= X"11111111";
    wait until falling_edge(a_clk_i);
    a_addr_i <= X"001";
    a_dat_i  <= X"22222222";
    wait until falling_edge(a_clk_i);
    a_addr_i <= X"002";
    a_be_i   <= "0011";
    a_dat_i  <= X"33333333";
    wait until falling_edge(a_clk_i);
    a_addr_i <= X"003";
    a_be_i   <= "0100";
    a_dat_i  <= X"44444444";
    wait until falling_edge(a_clk_i);
    a_wr_i   <= '0';

    -- Readback from port AddrA
    wait until falling_edge(a_clk_i);
    a_addr_i <= X"000";
    wait until falling_edge(a_clk_i);
    StdlvCompareStdlv(X"11111111", a_dat_o, "Wrong Data A 1");
    a_addr_i <= X"001";
    wait until falling_edge(a_clk_i);
    StdlvCompareStdlv(X"22222222", a_dat_o, "Wrong Data A 1");
    a_addr_i <= X"002";
    wait until falling_edge(a_clk_i);
    StdlvCompareStdlv(X"00003333", a_dat_o, "Wrong Data A 1");
    a_addr_i <= X"003";
    wait until falling_edge(a_clk_i);
    StdlvCompareStdlv(X"00440000", a_dat_o, "Wrong Data A 1");

    -- Readback from port AddrB
    wait until falling_edge(b_clk_i);
    b_addr_i <= X"000";
    wait until falling_edge(b_clk_i);
    StdlvCompareStdlv(X"11111111", b_dat_o, "Wrong Data B 1");
    b_addr_i <= X"001";
    wait until falling_edge(b_clk_i);
    StdlvCompareStdlv(X"22222222", b_dat_o, "Wrong Data B 1");
    b_addr_i <= X"002";
    wait until falling_edge(b_clk_i);
    StdlvCompareStdlv(X"00003333", b_dat_o, "Wrong Data B 1");
    b_addr_i <= X"003";
    wait until falling_edge(b_clk_i);
    StdlvCompareStdlv(X"00440000", b_dat_o, "Wrong Data B 1");

    -- Write from portB
    wait until falling_edge(b_clk_i);
    b_wr_i   <= '1';
    b_be_i   <= "1111";
    b_addr_i <= X"100";
    b_dat_i  <= X"AAAAAAAA";
    wait until falling_edge(b_clk_i);
    b_addr_i <= X"001";
    b_dat_i  <= X"BBBBBBBB";
    wait until falling_edge(b_clk_i);
    b_addr_i <= X"002";
    b_be_i   <= "1100";
    b_dat_i  <= X"CCCCCCCC";
    wait until falling_edge(b_clk_i);
    b_addr_i <= X"003";
    b_be_i   <= "0110";
    b_dat_i  <= X"DDDDDDDD";
    wait until falling_edge(b_clk_i);
    b_wr_i   <= '0';

    -- Readback from port AddrA
    wait until falling_edge(a_clk_i);
    a_addr_i <= X"000";
    wait until falling_edge(a_clk_i);
    StdlvCompareStdlv(X"11111111", a_dat_o, "Wrong Data A 2");
    a_addr_i <= X"100";
    wait until falling_edge(a_clk_i);
    StdlvCompareStdlv(X"AAAAAAAA", a_dat_o, "Wrong Data A 2");
    a_addr_i <= X"001";
    wait until falling_edge(a_clk_i);
    StdlvCompareStdlv(X"BBBBBBBB", a_dat_o, "Wrong Data A 2");
    a_addr_i <= X"002";
    wait until falling_edge(a_clk_i);
    StdlvCompareStdlv(X"CCCC3333", a_dat_o, "Wrong Data A 2");
    a_addr_i <= X"003";
    wait until falling_edge(a_clk_i);
    StdlvCompareStdlv(X"00DDDD00", a_dat_o, "Wrong Data A 2");

    -- Readback from port AddrB
    wait until falling_edge(b_clk_i);
    b_addr_i <= X"000";
    wait until falling_edge(b_clk_i);
    StdlvCompareStdlv(X"11111111", b_dat_o, "Wrong Data B 2");
    b_addr_i <= X"100";
    wait until falling_edge(b_clk_i);
    StdlvCompareStdlv(X"AAAAAAAA", b_dat_o, "Wrong Data B 2");
    b_addr_i <= X"001";
    wait until falling_edge(b_clk_i);
    StdlvCompareStdlv(X"BBBBBBBB", b_dat_o, "Wrong Data B 2");
    b_addr_i <= X"002";
    wait until falling_edge(b_clk_i);
    StdlvCompareStdlv(X"CCCC3333", b_dat_o, "Wrong Data B 2");
    b_addr_i <= X"003";
    wait until falling_edge(b_clk_i);
    StdlvCompareStdlv(X"00DDDD00", b_dat_o, "Wrong Data B 2");

    -- end of process !DO NOT EDIT!
    ProcessDone(TbProcNr_Stimuli_c) <= '1';
    wait;
  end process;

end;
