------------------------------------------------------------
-- Copyright (c) 2020 by Paul Scherrer Institute, Switzerland
-- All rights reserved.
------------------------------------------------------------

------------------------------------------------------------
-- Testbench generated by TbGen.py
------------------------------------------------------------
-- see Library/Python/TbGenerator

------------------------------------------------------------
-- Libraries
------------------------------------------------------------
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;
	use ieee.math_real.all;
	
library work;
	use work.psi_tb_txt_util.all;
	use work.psi_tb_axi_pkg.all;

------------------------------------------------------------
-- Entity Declaration
------------------------------------------------------------
entity psi_common_axi_multi_pl_stage_tb is
end entity;

------------------------------------------------------------
-- Architecture
------------------------------------------------------------
architecture sim of psi_common_axi_multi_pl_stage_tb is
	-- *** Fixed Generics ***
	
	-- *** Not Assigned Generics (default values) ***
	constant AddrWidth_g : positive := 16 ;
	constant DataWidth_g : positive := 32 ;
	constant Stages_g : positive := 3;
	
	-- *** TB Control ***
	signal TbRunning : boolean := True;
	signal NextCase : integer := -1;
	signal ProcessDone : std_logic_vector(0 to 1) := (others => '0');
	constant AllProcessesDone_c : std_logic_vector(0 to 1) := (others => '1');
	constant TbProcNr_master_c : integer := 0;
	constant TbProcNr_slave_c : integer := 1;
	
	-- *** DUT Signals ***
	signal Clk : std_logic := '1';
	signal Rst : std_logic := '1';
	
	-------------------------------------------------------------------------
	-- AXI Definition
	-------------------------------------------------------------------------
	constant ID_WIDTH 		: integer 	:= 1;
	constant ADDR_WIDTH 	: integer	:= 16;
	constant USER_WIDTH		: integer	:= 1;
	constant DATA_WIDTH		: integer	:= 32;
	constant BYTE_WIDTH		: integer	:= DATA_WIDTH/8;
	
	subtype ID_RANGE is natural range ID_WIDTH-1 downto 0;
	subtype ADDR_RANGE is natural range ADDR_WIDTH-1 downto 0;
	subtype USER_RANGE is natural range USER_WIDTH-1 downto 0;
	subtype DATA_RANGE is natural range DATA_WIDTH-1 downto 0;
	subtype BYTE_RANGE is natural range BYTE_WIDTH-1 downto 0;
	
	signal axi_ms_m, axi_ms_s : axi_ms_r (	arid(ID_RANGE), awid(ID_RANGE),
								araddr(ADDR_RANGE), awaddr(ADDR_RANGE),
								aruser(USER_RANGE), awuser(USER_RANGE), wuser(USER_RANGE),
								wdata(DATA_RANGE),
								wstrb(BYTE_RANGE));
	
	signal axi_sm_m, axi_sm_s : axi_sm_r (	rid(ID_RANGE), bid(ID_RANGE),
								ruser(USER_RANGE), buser(USER_RANGE),
								rdata(DATA_RANGE));
	
begin
	------------------------------------------------------------
	-- DUT Instantiation
	------------------------------------------------------------
	i_dut : entity work.psi_common_axi_multi_pl_stage
		generic map (
			AddrWidth_g => AddrWidth_g,
			DataWidth_g => DataWidth_g,
			Stages_g => Stages_g
		)
		port map (
			Clk => Clk,
			Rst => Rst,
			InAwAddr => axi_ms_m.awaddr,
			InAwValid => axi_ms_m.awvalid,
			InAwReady => axi_sm_m.awready,
			InAwLen => axi_ms_m.awlen,
			InAwSize => axi_ms_m.awsize,
			InAwBurst => axi_ms_m.awburst,
			InAwLock => axi_ms_m.awlock,
			InAwCache => axi_ms_m.awcache,
			InAwProt => axi_ms_m.awprot,
			InWData => axi_ms_m.wdata,
			InWStrb => axi_ms_m.wstrb,
			InWValid => axi_ms_m.wvalid,
			InWReady => axi_sm_m.wready,
			InWLast => axi_ms_m.wlast,
			InBResp => axi_sm_m.bresp,
			InBValid => axi_sm_m.bvalid,
			InBReady => axi_ms_m.bready,
			InArAddr => axi_ms_m.araddr,
			InArValid => axi_ms_m.arvalid,
			InArReady => axi_sm_m.arready,
			InArLen => axi_ms_m.arlen,
			InArSize => axi_ms_m.arsize,
			InArBurst => axi_ms_m.arburst,
			InArLock => axi_ms_m.arlock,
			InArCache => axi_ms_m.arcache,
			InArProt => axi_ms_m.arprot,
			InRData => axi_sm_m.rdata,
			InRValid => axi_sm_m.rvalid,
			InRReady => axi_ms_m.rready,
			InRResp => axi_sm_m.rresp,
			InRLast => axi_sm_m.rlast,
			OutAwAddr => axi_ms_s.awaddr,
			OutAwValid => axi_ms_s.awvalid,
			OutAwReady => axi_sm_s.awready,
			OutAwLen => axi_ms_s.awlen,
			OutAwSize => axi_ms_s.awsize,
			OutAwBurst => axi_ms_s.awburst,
			OutAwLock => axi_ms_s.awlock,
			OutAwCache => axi_ms_s.awcache,
			OutAwProt => axi_ms_s.awprot,
			OutWData => axi_ms_s.wdata,
			OutWStrb => axi_ms_s.wstrb,
			OutWValid => axi_ms_s.wvalid,
			OutWReady => axi_sm_s.wready,
			OutWLast => axi_ms_s.wlast,
			OutBResp => axi_sm_s.bresp,
			OutBValid => axi_sm_s.bvalid,
			OutBReady => axi_ms_s.bready,
			OutArAddr => axi_ms_s.araddr,
			OutArValid => axi_ms_s.arvalid,
			OutArReady => axi_sm_s.arready,
			OutArLen => axi_ms_s.arlen,
			OutArSize => axi_ms_s.arsize,
			OutArBurst => axi_ms_s.arburst,
			OutArLock => axi_ms_s.arlock,
			OutArCache => axi_ms_s.arcache,
			OutArProt => axi_ms_s.arprot,
			OutRData => axi_sm_s.rdata,
			OutRValid => axi_sm_s.rvalid,
			OutRReady => axi_ms_s.rready,
			OutRResp => axi_sm_s.rresp,
			OutRLast => axi_sm_s.rlast
		);
	
	------------------------------------------------------------
	-- Testbench Control !DO NOT EDIT!
	------------------------------------------------------------
	p_tb_control : process
	begin
		wait until Rst = '0';
		wait until ProcessDone = AllProcessesDone_c;
		TbRunning <= false;
		wait;
	end process;
	
	------------------------------------------------------------
	-- Clocks !DO NOT EDIT!
	------------------------------------------------------------
	p_clock_Clk : process
		constant Frequency_c : real := real(100.0e6);
	begin
		while TbRunning loop
			wait for 0.5*(1 sec)/Frequency_c;
			Clk <= not Clk;
		end loop;
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Resets
	------------------------------------------------------------
	p_rst_Rst : process
	begin
		wait for 1 us;
		-- Wait for two clk edges to ensure reset is active for at least one edge
		wait until rising_edge(Clk);
		wait until rising_edge(Clk);
		Rst <= '0';
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Processes
	------------------------------------------------------------
	-- *** master ***
	p_master : process
	begin
		-- start of process !DO NOT EDIT
		wait until Rst = '0';
		
		-- User Code
		axi_single_write(16#1234#, 16#87654321#, axi_ms_m, axi_sm_m, Clk);
		axi_single_expect(16#12AB#, 16#3456CDEF#, axi_ms_m, axi_sm_m, Clk);
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_master_c) <= '1';
		wait;
	end process;
	
	-- *** slave ***
	p_slave : process
	begin
		-- start of process !DO NOT EDIT
		wait until Rst = '0';
		
		-- User Code
		axi_expect_aw(16#1234#, AxSIZE_4_c, 1-1, xBURST_INCR_c, axi_ms_s, axi_sm_s, Clk);
		axi_expect_wd_single(X"87654321", "1111", axi_ms_s, axi_sm_s, Clk);
		axi_apply_bresp(xRESP_OKAY_c, axi_ms_s, axi_sm_s, Clk);

		axi_expect_ar(16#12AB#, AxSIZE_4_c, 1-1, xBURST_INCR_c, axi_ms_s, axi_sm_s, Clk);
		axi_apply_rresp_single(X"3456CDEF", xRESP_OKAY_c, axi_ms_s, axi_sm_s, Clk);	
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_slave_c) <= '1';
		wait;
	end process;
	
	
end;
