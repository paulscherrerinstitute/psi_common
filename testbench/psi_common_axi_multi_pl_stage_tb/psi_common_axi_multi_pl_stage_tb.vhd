------------------------------------------------------------
-- Copyright (c) 2020 by Paul Scherrer Institute, Switzerland
-- All rights reserved.
------------------------------------------------------------

------------------------------------------------------------
-- Testbench generated by TbGen.py
------------------------------------------------------------
-- see Library/Python/TbGenerator

------------------------------------------------------------
-- Libraries
------------------------------------------------------------
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;
	use ieee.math_real.all;
	
library work;
	use work.psi_tb_txt_util.all;
	use work.psi_tb_axi_pkg.all;

------------------------------------------------------------
-- Entity Declaration
------------------------------------------------------------
entity psi_common_axi_multi_pl_stage_tb is
end entity;

------------------------------------------------------------
-- Architecture
------------------------------------------------------------
architecture sim of psi_common_axi_multi_pl_stage_tb is
	-- *** Fixed Generics ***
	
	-- *** Not Assigned Generics (default values) ***
	constant addr_width_g : positive := 16 ;
	constant data_width_g : positive := 32 ;
	constant stages_g : positive := 3;
	
	-- *** TB Control ***
	signal TbRunning : boolean := True;
	signal NextCase : integer := -1;
	signal ProcessDone : std_logic_vector(0 to 1) := (others => '0');
	constant AllProcessesDone_c : std_logic_vector(0 to 1) := (others => '1');
	constant TbProcNr_master_c : integer := 0;
	constant TbProcNr_slave_c : integer := 1;
	
	-- *** DUT Signals ***
	signal clk_i : std_logic := '1';
	signal rst_i : std_logic := '1';
	
	-------------------------------------------------------------------------
	-- AXI Definition
	-------------------------------------------------------------------------
	constant ID_WIDTH 		: integer 	:= 1;
	constant ADDR_WIDTH 	: integer	:= 16;
	constant USER_WIDTH		: integer	:= 1;
	constant DATA_WIDTH		: integer	:= 32;
	constant BYTE_WIDTH		: integer	:= DATA_WIDTH/8;
	
	subtype ID_RANGE is natural range ID_WIDTH-1 downto 0;
	subtype ADDR_RANGE is natural range ADDR_WIDTH-1 downto 0;
	subtype USER_RANGE is natural range USER_WIDTH-1 downto 0;
	subtype DATA_RANGE is natural range DATA_WIDTH-1 downto 0;
	subtype BYTE_RANGE is natural range BYTE_WIDTH-1 downto 0;
	
	signal axi_ms_m, axi_ms_s : axi_ms_r (	arid(ID_RANGE), awid(ID_RANGE),
								araddr(ADDR_RANGE), awaddr(ADDR_RANGE),
								aruser(USER_RANGE), awuser(USER_RANGE), wuser(USER_RANGE),
								wdata(DATA_RANGE),
								wstrb(BYTE_RANGE));
	
	signal axi_sm_m, axi_sm_s : axi_sm_r (	rid(ID_RANGE), bid(ID_RANGE),
								ruser(USER_RANGE), buser(USER_RANGE),
								rdata(DATA_RANGE));
	
begin
	------------------------------------------------------------
	-- DUT Instantiation
	------------------------------------------------------------
	i_dut : entity work.psi_common_axi_multi_pl_stage
		generic map (
			addr_width_g => addr_width_g,
			data_width_g => data_width_g,
			stages_g => stages_g
		)
		port map (
			clk_i => clk_i,
			rst_i => rst_i,
			in_awaddr => axi_ms_m.awaddr,
			in_awvalid => axi_ms_m.awvalid,
			in_awready => axi_sm_m.awready,
			in_awlen => axi_ms_m.awlen,
			in_awsize => axi_ms_m.awsize,
			in_awburst => axi_ms_m.awburst,
			in_awlock => axi_ms_m.awlock,
			in_awcache => axi_ms_m.awcache,
			in_awprot => axi_ms_m.awprot,
			in_wdata => axi_ms_m.wdata,
			in_wstrb => axi_ms_m.wstrb,
			in_wvalid => axi_ms_m.wvalid,
			in_wready => axi_sm_m.wready,
			in_wlast => axi_ms_m.wlast,
			in_bresp => axi_sm_m.bresp,
			in_bvalid => axi_sm_m.bvalid,
			in_bready => axi_ms_m.bready,
			in_araddr => axi_ms_m.araddr,
			in_arvalid => axi_ms_m.arvalid,
			in_arready => axi_sm_m.arready,
			in_arlen => axi_ms_m.arlen,
			in_arsize => axi_ms_m.arsize,
			in_arburst => axi_ms_m.arburst,
			in_arlock => axi_ms_m.arlock,
			in_arcache => axi_ms_m.arcache,
			in_arprot => axi_ms_m.arprot,
			in_rdata => axi_sm_m.rdata,
			in_rvalid => axi_sm_m.rvalid,
			in_rready => axi_ms_m.rready,
			in_rresp => axi_sm_m.rresp,
			in_rlast => axi_sm_m.rlast,
			out_awaddr => axi_ms_s.awaddr,
			out_awvalid => axi_ms_s.awvalid,
			out_awready => axi_sm_s.awready,
			out_awlen => axi_ms_s.awlen,
			out_awsize => axi_ms_s.awsize,
			out_awburst => axi_ms_s.awburst,
			out_awlock => axi_ms_s.awlock,
			out_awcache => axi_ms_s.awcache,
			out_awprot => axi_ms_s.awprot,
			out_wdata => axi_ms_s.wdata,
			out_wstrb => axi_ms_s.wstrb,
			out_wvalid => axi_ms_s.wvalid,
			out_wready => axi_sm_s.wready,
			out_wlast => axi_ms_s.wlast,
			out_bresp => axi_sm_s.bresp,
			out_bvalid => axi_sm_s.bvalid,
			out_bready => axi_ms_s.bready,
			out_araddr => axi_ms_s.araddr,
			out_arvalid => axi_ms_s.arvalid,
			out_arready => axi_sm_s.arready,
			out_arlen => axi_ms_s.arlen,
			out_arsize => axi_ms_s.arsize,
			out_arburst => axi_ms_s.arburst,
			out_arlock => axi_ms_s.arlock,
			out_arcache => axi_ms_s.arcache,
			out_arprot => axi_ms_s.arprot,
			out_rdata => axi_sm_s.rdata,
			out_rvalid => axi_sm_s.rvalid,
			out_rready => axi_ms_s.rready,
			out_rresp => axi_sm_s.rresp,
			out_rlast => axi_sm_s.rlast
		);
	
	------------------------------------------------------------
	-- Testbench Control !DO NOT EDIT!
	------------------------------------------------------------
	p_tb_control : process
	begin
		wait until rst_i = '0';
		wait until ProcessDone = AllProcessesDone_c;
		TbRunning <= false;
		wait;
	end process;
	
	------------------------------------------------------------
	-- Clocks !DO NOT EDIT!
	------------------------------------------------------------
	p_clock_Clk : process
		constant Frequency_c : real := real(100.0e6);
	begin
		while TbRunning loop
			wait for 0.5*(1 sec)/Frequency_c;
			clk_i <= not clk_i;
		end loop;
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Resets
	------------------------------------------------------------
	p_rst_Rst : process
	begin
		wait for 1 us;
		-- Wait for two clk edges to ensure reset is active for at least one edge
		wait until rising_edge(clk_i);
		wait until rising_edge(clk_i);
		rst_i <= '0';
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Processes
	------------------------------------------------------------
	-- *** master ***
	p_master : process
	begin
		-- start of process !DO NOT EDIT
		wait until rst_i = '0';
		
		-- User Code
		axi_single_write(16#1234#, 16#37654321#, axi_ms_m, axi_sm_m, clk_i);
		axi_single_expect(16#12AB#, 16#3456CDEF#, axi_ms_m, axi_sm_m, clk_i);
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_master_c) <= '1';
		wait;
	end process;
	
	-- *** slave ***
	p_slave : process
	begin
		-- start of process !DO NOT EDIT
		wait until rst_i = '0';
		
		-- User Code
		axi_expect_aw(16#1234#, AxSIZE_4_c, 1-1, xBURST_INCR_c, axi_ms_s, axi_sm_s, clk_i);
		axi_expect_wd_single(X"37654321", "1111", axi_ms_s, axi_sm_s, clk_i);
		axi_apply_bresp(xRESP_OKAY_c, axi_ms_s, axi_sm_s, clk_i);

		axi_expect_ar(16#12AB#, AxSIZE_4_c, 1-1, xBURST_INCR_c, axi_ms_s, axi_sm_s, clk_i);
		axi_apply_rresp_single(X"3456CDEF", xRESP_OKAY_c, axi_ms_s, axi_sm_s, clk_i);	
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_slave_c) <= '1';
		wait;
	end process;
	
	
end;
