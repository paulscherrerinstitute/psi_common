------------------------------------------------------------
-- Copyright (c) 2019 by Paul Scherrer Institute, Switzerland
-- All rights reserved.
------------------------------------------------------------

------------------------------------------------------------
-- Testbench generated by TbGen.py
------------------------------------------------------------
-- see Library/Python/TbGenerator

------------------------------------------------------------
-- Libraries
------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.psi_common_math_pkg.all;
use work.psi_common_logic_pkg.all;

library work;
use work.psi_tb_txt_util.all;
use work.psi_tb_compare_pkg.all;
use work.psi_tb_activity_pkg.all;
use work.psi_tb_axi_pkg.all;

library work;
use work.psi_common_axi_master_simple_tb_pkg.all;

library work;
use work.psi_common_axi_master_simple_tb_case_simple_tf.all;
use work.psi_common_axi_master_simple_tb_case_max_transact.all;
use work.psi_common_axi_master_simple_tb_case_axi_hs.all;
use work.psi_common_axi_master_simple_tb_case_split.all;
use work.psi_common_axi_master_simple_tb_case_internals.all;
use work.psi_common_axi_master_simple_tb_case_special.all;

------------------------------------------------------------
-- Entity Declaration
------------------------------------------------------------
entity psi_common_axi_master_simple_tb is
  generic(
    impl_write_g : boolean := true;
    impl_read_g  : boolean := true
  );
end entity;

------------------------------------------------------------
-- Architecture
------------------------------------------------------------
architecture sim of psi_common_axi_master_simple_tb is

  -- *** Not Assigned Generics (default values) ***

  -- *** AXI ***
  signal axi_ms : axi_ms_t;
  signal axi_sm : axi_sm_t;

  -- *** Exported Generics ***
  constant Generics_c : Generics_t := (
    impl_read_g  => impl_read_g,
    impl_write_g => impl_write_g);

  -- *** TB Control ***
  signal TbRunning              : boolean                  := True;
  signal NextCase               : integer                  := -1;
  signal ProcessDone            : std_logic_vector(0 to 3) := (others => '0');
  constant AllProcessesDone_c   : std_logic_vector(0 to 3) := (others => '1');
  constant TbProcNr_user_cmd_c  : integer                  := 0;
  constant TbProcNr_user_data_c : integer                  := 1;
  constant TbProcNr_user_resp_c : integer                  := 2;
  constant TbProcNr_axi_c       : integer                  := 3;

  -- *** DUT Signals ***
  signal m_axi_aclk    : std_logic                                                := '1';
  signal m_axi_aresetn : std_logic                                                := '0';
  signal cmd_wr_addr_i    : std_logic_vector(axi_addr_width_g - 1 downto 0)            := (others => '0');
  signal cmd_wr_size_i    : std_logic_vector(user_transaction_size_bits_g - 1 downto 0) := (others => '0');
  signal cmd_wr_low_lat_i  : std_logic                                                := '0';
  signal cmd_wr_vld_i     : std_logic                                                := '0';
  signal cmd_wr_rdy_o     : std_logic                                                := '0';
  signal cmd_rd_addr_i    : std_logic_vector(axi_addr_width_g - 1 downto 0)            := (others => '0');
  signal cmd_rd_size_o    : std_logic_vector(user_transaction_size_bits_g - 1 downto 0) := (others => '0');
  signal cmd_rd_low_lat_i  : std_logic                                                := '0';
  signal cmd_rd_vld_i     : std_logic                                                := '0';
  signal cmd_rd_rdy_o     : std_logic                                                := '0';
  signal wr_dat_i    : std_logic_vector(axi_data_width_g - 1 downto 0)            := (others => '0');
  signal wr_data_be      : std_logic_vector(axi_data_width_g / 8 - 1 downto 0)        := (others => '0');
  signal wr_vld_i     : std_logic                                                := '0';
  signal wr_rdy_o     : std_logic                                                := '0';
  signal rd_dat_o    : std_logic_vector(axi_data_width_g - 1 downto 0)            := (others => '0');
  signal rd_vld_o     : std_logic                                                := '0';
  signal rd_rdy_i     : std_logic                                                := '0';
  signal wr_done_o       : std_logic                                                := '0';
  signal wr_error_o      : std_logic                                                := '0';
  signal rd_done_o       : std_logic                                                := '0';
  signal rd_error_o      : std_logic                                                := '0';

begin
  ------------------------------------------------------------
  -- DUT Instantiation
  ------------------------------------------------------------
  i_dut : entity work.psi_common_axi_master_simple
    generic map(
      axi_addr_width_g            => axi_addr_width_g,
      axi_data_width_g            => axi_data_width_g,
      axi_max_beats_g             => axi_max_beats_g,
      axi_max_open_transactions_g   => axi_max_open_transactions_g,
      user_transaction_size_bits_g => user_transaction_size_bits_g,
      data_fifo_depth_g           => data_fifo_depth_g,
      impl_write_g               => impl_write_g,
      impl_read_g                => impl_read_g,
      ram_behavior_g             => ram_behavior_g
    )
    port map(
      m_axi_aclk    => m_axi_aclk,
      m_axi_aresetn => m_axi_aresetn,
      cmd_wr_addr_i    => cmd_wr_addr_i,
      cmd_wr_size_i    => cmd_wr_size_i,
      cmd_wr_low_lat_i  => cmd_wr_low_lat_i,
      cmd_wr_vld_i     => cmd_wr_vld_i,
      cmd_wr_rdy_o     => cmd_wr_rdy_o,
      cmd_rd_addr_i    => cmd_rd_addr_i,
      cmd_rd_size_o    => cmd_rd_size_o,
      cmd_rd_low_lat_i  => cmd_rd_low_lat_i,
      cmd_rd_vld_i     => cmd_rd_vld_i,
      cmd_rd_rdy_o     => cmd_rd_rdy_o,
      wr_dat_i    => wr_dat_i,
      wr_data_be      => wr_data_be,
      wr_vld_i     => wr_vld_i,
      wr_rdy_o     => wr_rdy_o,
      rd_dat_o    => rd_dat_o,
      rd_vld_o     => rd_vld_o,
      rd_rdy_i     => rd_rdy_i,
      wr_done_o       => wr_done_o,
      wr_error_o      => wr_error_o,
      rd_done_o       => rd_done_o,
      rd_error_o      => rd_error_o,
      m_axi_awaddr  => axi_ms.awaddr,
      m_axi_awlen   => axi_ms.awlen,
      m_axi_awsize  => axi_ms.awsize,
      m_axi_awburst => axi_ms.awburst,
      m_axi_awlock  => axi_ms.awlock,
      m_axi_awcache => axi_ms.awcache,
      m_axi_awprot  => axi_ms.awprot,
      m_axi_awvalid => axi_ms.awvalid,
      m_axi_awready => axi_sm.awready,
      m_axi_wdata   => axi_ms.wdata,
      m_axi_wstrb   => axi_ms.wstrb,
      m_axi_wlast   => axi_ms.wlast,
      m_axi_wvalid  => axi_ms.wvalid,
      m_axi_wready  => axi_sm.wready,
      m_axi_bresp   => axi_sm.bresp,
      m_axi_bvalid  => axi_sm.bvalid,
      m_axi_bready  => axi_ms.bready,
      m_axi_araddr  => axi_ms.araddr,
      m_axi_arlen   => axi_ms.arlen,
      m_axi_arsize  => axi_ms.arsize,
      m_axi_arburst => axi_ms.arburst,
      m_axi_arlock  => axi_ms.arlock,
      m_axi_arcache => axi_ms.arcache,
      m_axi_arprot  => axi_ms.arprot,
      m_axi_arvalid => axi_ms.arvalid,
      m_axi_arready => axi_sm.arready,
      m_axi_rdata   => axi_sm.rdata,
      m_axi_rresp   => axi_sm.rresp,
      m_axi_rlast   => axi_sm.rlast,
      m_axi_rvalid  => axi_sm.rvalid,
      m_axi_rready  => axi_ms.rready
    );

  ------------------------------------------------------------
  -- Testbench Control !DO NOT EDIT!
  ------------------------------------------------------------
  p_tb_control : process
  begin
    wait until m_axi_aresetn = '1';
    -- simple_tf
    NextCase  <= 0;
    wait until ProcessDone = AllProcessesDone_c;
    -- max_transact
    NextCase  <= 1;
    wait until ProcessDone = AllProcessesDone_c;
    -- axi_hs
    NextCase  <= 2;
    wait until ProcessDone = AllProcessesDone_c;
    -- split
    NextCase  <= 3;
    wait until ProcessDone = AllProcessesDone_c;
    -- internals
    NextCase  <= 4;
    wait until ProcessDone = AllProcessesDone_c;
    -- highlat
    NextCase  <= 5;
    wait until ProcessDone = AllProcessesDone_c;
    TbRunning <= false;
    wait;
  end process;

  ------------------------------------------------------------
  -- Clocks !DO NOT EDIT!
  ------------------------------------------------------------
  p_clock_M_Axi_Aclk : process
    constant Frequency_c : real := real(100e6);
  begin
    while TbRunning loop
      wait for 0.5 * (1 sec) / Frequency_c;
      m_axi_aclk <= not m_axi_aclk;
    end loop;
    wait;
  end process;

  ------------------------------------------------------------
  -- Resets
  ------------------------------------------------------------
  p_rst_M_Axi_Aresetn : process
  begin
    wait for 1 us;
    -- Wait for two clk edges to ensure reset is active for at least one edge
    wait until rising_edge(m_axi_aclk);
    wait until rising_edge(m_axi_aclk);
    m_axi_aresetn <= '1';
    wait;
  end process;

  ------------------------------------------------------------
  -- Processes !DO NOT EDIT!
  ------------------------------------------------------------
  -- *** user_cmd ***
  p_user_cmd : process
  begin
    -- simple_tf
    wait until NextCase = 0;
    ProcessDone(TbProcNr_user_cmd_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_simple_tf.user_cmd(cmd_wr_addr_i, cmd_wr_size_i, cmd_wr_low_lat_i, cmd_wr_vld_i, cmd_wr_rdy_o, cmd_rd_addr_i, cmd_rd_size_o, cmd_rd_low_lat_i, cmd_rd_vld_i, cmd_rd_rdy_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_cmd_c) <= '1';
    -- max_transact
    wait until NextCase = 1;
    ProcessDone(TbProcNr_user_cmd_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_max_transact.user_cmd(cmd_wr_addr_i, cmd_wr_size_i, cmd_wr_low_lat_i, cmd_wr_vld_i, cmd_wr_rdy_o, cmd_rd_addr_i, cmd_rd_size_o, cmd_rd_low_lat_i, cmd_rd_vld_i, cmd_rd_rdy_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_cmd_c) <= '1';
    -- axi_hs
    wait until NextCase = 2;
    ProcessDone(TbProcNr_user_cmd_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_axi_hs.user_cmd(cmd_wr_addr_i, cmd_wr_size_i, cmd_wr_low_lat_i, cmd_wr_vld_i, cmd_wr_rdy_o, cmd_rd_addr_i, cmd_rd_size_o, cmd_rd_low_lat_i, cmd_rd_vld_i, cmd_rd_rdy_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_cmd_c) <= '1';
    -- split
    wait until NextCase = 3;
    ProcessDone(TbProcNr_user_cmd_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_split.user_cmd(cmd_wr_addr_i, cmd_wr_size_i, cmd_wr_low_lat_i, cmd_wr_vld_i, cmd_wr_rdy_o, cmd_rd_addr_i, cmd_rd_size_o, cmd_rd_low_lat_i, cmd_rd_vld_i, cmd_rd_rdy_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_cmd_c) <= '1';
    -- internals
    wait until NextCase = 4;
    ProcessDone(TbProcNr_user_cmd_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_internals.user_cmd(cmd_wr_addr_i, cmd_wr_size_i, cmd_wr_low_lat_i, cmd_wr_vld_i, cmd_wr_rdy_o, cmd_rd_addr_i, cmd_rd_size_o, cmd_rd_low_lat_i, cmd_rd_vld_i, cmd_rd_rdy_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_cmd_c) <= '1';
    -- special cases
    wait until NextCase = 5;
    ProcessDone(TbProcNr_user_cmd_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_special.user_cmd(cmd_wr_addr_i, cmd_wr_size_i, cmd_wr_low_lat_i, cmd_wr_vld_i, cmd_wr_rdy_o, cmd_rd_addr_i, cmd_rd_size_o, cmd_rd_low_lat_i, cmd_rd_vld_i, cmd_rd_rdy_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_cmd_c) <= '1';
    wait;
  end process;

  -- *** user_data ***
  p_user_data : process
  begin
    -- simple_tf
    wait until NextCase = 0;
    ProcessDone(TbProcNr_user_data_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_simple_tf.user_data(wr_dat_i, wr_data_be, wr_vld_i, wr_rdy_o, rd_dat_o, rd_vld_o, rd_rdy_i, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_data_c) <= '1';
    -- max_transact
    wait until NextCase = 1;
    ProcessDone(TbProcNr_user_data_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_max_transact.user_data(wr_dat_i, wr_data_be, wr_vld_i, wr_rdy_o, rd_dat_o, rd_vld_o, rd_rdy_i, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_data_c) <= '1';
    -- axi_hs
    wait until NextCase = 2;
    ProcessDone(TbProcNr_user_data_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_axi_hs.user_data(wr_dat_i, wr_data_be, wr_vld_i, wr_rdy_o, rd_dat_o, rd_vld_o, rd_rdy_i, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_data_c) <= '1';
    -- split
    wait until NextCase = 3;
    ProcessDone(TbProcNr_user_data_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_split.user_data(wr_dat_i, wr_data_be, wr_vld_i, wr_rdy_o, rd_dat_o, rd_vld_o, rd_rdy_i, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_data_c) <= '1';
    -- internals
    wait until NextCase = 4;
    ProcessDone(TbProcNr_user_data_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_internals.user_data(wr_dat_i, wr_data_be, wr_vld_i, wr_rdy_o, rd_dat_o, rd_vld_o, rd_rdy_i, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_data_c) <= '1';
    -- special cases
    wait until NextCase = 5;
    ProcessDone(TbProcNr_user_data_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_special.user_data(wr_dat_i, wr_data_be, wr_vld_i, wr_rdy_o, rd_dat_o, rd_vld_o, rd_rdy_i, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_data_c) <= '1';
    wait;
  end process;

  -- *** user_resp ***
  p_user_resp : process
  begin
    -- simple_tf
    wait until NextCase = 0;
    ProcessDone(TbProcNr_user_resp_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_simple_tf.user_resp(wr_done_o, wr_error_o, rd_done_o, rd_error_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_resp_c) <= '1';
    -- max_transact
    wait until NextCase = 1;
    ProcessDone(TbProcNr_user_resp_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_max_transact.user_resp(wr_done_o, wr_error_o, rd_done_o, rd_error_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_resp_c) <= '1';
    -- axi_hs
    wait until NextCase = 2;
    ProcessDone(TbProcNr_user_resp_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_axi_hs.user_resp(wr_done_o, wr_error_o, rd_done_o, rd_error_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_resp_c) <= '1';
    -- split
    wait until NextCase = 3;
    ProcessDone(TbProcNr_user_resp_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_split.user_resp(wr_done_o, wr_error_o, rd_done_o, rd_error_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_resp_c) <= '1';
    -- internals
    wait until NextCase = 4;
    ProcessDone(TbProcNr_user_resp_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_internals.user_resp(wr_done_o, wr_error_o, rd_done_o, rd_error_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_resp_c) <= '1';
    -- special cases
    wait until NextCase = 5;
    ProcessDone(TbProcNr_user_resp_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_special.user_resp(wr_done_o, wr_error_o, rd_done_o, rd_error_o, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_user_resp_c) <= '1';
    wait;
  end process;

  -- *** axi ***
  p_axi : process
  begin
    -- simple_tf
    wait until NextCase = 0;
    ProcessDone(TbProcNr_axi_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_simple_tf.axi(axi_ms, axi_sm, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_axi_c) <= '1';
    -- max_transact
    wait until NextCase = 1;
    ProcessDone(TbProcNr_axi_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_max_transact.axi(axi_ms, axi_sm, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_axi_c) <= '1';
    -- axi_hs
    wait until NextCase = 2;
    ProcessDone(TbProcNr_axi_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_axi_hs.axi(axi_ms, axi_sm, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_axi_c) <= '1';
    -- split
    wait until NextCase = 3;
    ProcessDone(TbProcNr_axi_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_split.axi(axi_ms, axi_sm, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_axi_c) <= '1';
    -- internals
    wait until NextCase = 4;
    ProcessDone(TbProcNr_axi_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_internals.axi(axi_ms, axi_sm, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_axi_c) <= '1';
    -- special cases
    wait until NextCase = 5;
    ProcessDone(TbProcNr_axi_c) <= '0';
    work.psi_common_axi_master_simple_tb_case_special.axi(axi_ms, axi_sm, m_axi_aclk, Generics_c);
    wait for 1 ps;
    ProcessDone(TbProcNr_axi_c) <= '1';
    wait;
  end process;

end;
