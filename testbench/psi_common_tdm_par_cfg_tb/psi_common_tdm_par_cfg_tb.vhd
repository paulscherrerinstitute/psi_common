------------------------------------------------------------------------------
--  Copyright (c) 2020 by Paul Scherrer Institute, Switzerland
--  All rights reserved.
--  Authors: Oliver Bruendler, Daniele Felici
------------------------------------------------------------------------------

------------------------------------------------------------
-- Testbench generated by TbGen.py
------------------------------------------------------------
-- see Library/Python/TbGenerator

------------------------------------------------------------
-- Libraries
------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.psi_common_math_pkg.all;
use work.psi_common_logic_pkg.all;
use work.psi_common_array_pkg.all;
use work.psi_tb_compare_pkg.all;

------------------------------------------------------------
-- Entity Declaration
------------------------------------------------------------
entity psi_common_tdm_par_cfg_tb is
end entity;

------------------------------------------------------------
-- Architecture
------------------------------------------------------------
architecture sim of psi_common_tdm_par_cfg_tb is
  -- *** Fixed Generics ***
  constant channel_count_g : natural := 3;
  constant channel_width_g : natural := 8;

  -- *** Not Assigned Generics (default values) ***

  -- *** TB Control ***
  signal TbRunning            : boolean                  := True;
  signal ProcessDone          : std_logic_vector(0 to 1) := (others => '0');
  constant AllProcessesDone_c : std_logic_vector(0 to 1) := (others => '1');
  constant TbProcNr_inp_c     : integer                  := 0;
  constant TbProcNr_outp_c    : integer                  := 1;

  -- *** DUT Signals ***
  signal clk_i             : std_logic                                                      := '1';
  signal rst_i             : std_logic                                                      := '1';
  signal enabled_channels_i : natural range 0 to channel_count_g                              := channel_count_g;
  signal dat_i             : std_logic_vector(channel_width_g - 1 downto 0)                  := (others => '0');
  signal vld_i          : std_logic                                                      := '0';
  signal last_i         : std_logic                                                      := '0';
  signal dat_o        : std_logic_vector(channel_count_g * channel_width_g - 1 downto 0) := (others => '0');
  signal vld_o     : std_logic                                                      := '0';

  -- handwritten
  signal TestCase : integer := -1;

  procedure Expect3Channels(Values : in t_ainteger(0 to 2)) is
  begin
    wait until rising_edge(clk_i) and vld_o = '1';
    StdlvCompareInt(Values(0), dat_o(1 * channel_width_g - 1 downto 0 * channel_width_g), "Wrong value Channel 0", false);
    StdlvCompareInt(Values(1), dat_o(2 * channel_width_g - 1 downto 1 * channel_width_g), "Wrong value Channel 1", false);
    StdlvCompareInt(Values(2), dat_o(3 * channel_width_g - 1 downto 2 * channel_width_g), "Wrong value Channel 2", false);
  end procedure;

  procedure Expect2Channels(Values : in t_ainteger(0 to 1)) is
  begin
    wait until rising_edge(clk_i) and vld_o = '1';
    StdlvCompareInt(Values(0), dat_o(1 * channel_width_g - 1 downto 0 * channel_width_g), "Wrong value Channel 0", false);
    StdlvCompareInt(Values(1), dat_o(2 * channel_width_g - 1 downto 1 * channel_width_g), "Wrong value Channel 1", false);
  end procedure;

  procedure Expect1Channel(Value : in integer) is
  begin
    wait until rising_edge(clk_i) and vld_o = '1';
    StdlvCompareInt(Value, dat_o(1 * channel_width_g - 1 downto 0 * channel_width_g), "Wrong value Channel 0", false);
  end procedure;

begin
  ------------------------------------------------------------
  -- DUT Instantiation
  ------------------------------------------------------------
  i_dut : entity work.psi_common_tdm_par_cfg
    generic map(
      ch_nb_g => channel_count_g,
      width_g => channel_width_g
    )
    port map(
      clk_i             => clk_i,
      rst_i             => rst_i,
      enabled_ch_i => enabled_channels_i,
      dat_i             => dat_i,
      vld_i          => vld_i,
      last_i         => last_i,
      dat_o        => dat_o,
      vld_o     => vld_o
    );

  ------------------------------------------------------------
  -- Testbench Control !DO NOT EDIT!
  ------------------------------------------------------------
  p_tb_control : process
  begin
    wait until rst_i = '0';
    wait until ProcessDone = AllProcessesDone_c;
    TbRunning <= false;
    wait;
  end process;

  ------------------------------------------------------------
  -- Clocks !DO NOT EDIT!
  ------------------------------------------------------------
  p_clock_Clk : process
    constant Frequency_c : real := real(100e6);
  begin
    while TbRunning loop
      wait for 0.5 * (1 sec) / Frequency_c;
      clk_i <= not clk_i;
    end loop;
    wait;
  end process;

  ------------------------------------------------------------
  -- Resets
  ------------------------------------------------------------
  p_rst_Rst : process
  begin
    wait for 1 us;
    -- Wait for two clk edges to ensure reset is active for at least one edge
    wait until rising_edge(clk_i);
    wait until rising_edge(clk_i);
    rst_i <= '0';
    wait;
  end process;

  ------------------------------------------------------------
  -- Processes
  ------------------------------------------------------------
  -- *** inp ***
  p_inp : process
  begin
    -- start of process !DO NOT EDIT
    wait until rst_i = '0';

    -- *** TdmLast not used ***
    -- *** max input length (EnabledChannels = ChannelCount_g) ***
    -- *** Samples with much space in between ***
    TestCase        <= 0;
    enabled_channels_i <= channel_count_g;
    wait until rising_edge(clk_i);
    for sample in 0 to 3 loop
      for channel in 0 to 2 loop
        vld_i <= '1';
        dat_i    <= std_logic_vector(to_unsigned(channel * 16#10# + sample, dat_i'length));
        wait until rising_edge(clk_i);
        vld_i <= '0';
        dat_i    <= (others => '0');
        for del in 0 to 9 loop
          wait until rising_edge(clk_i);
        end loop;
      end loop;
    end loop;

    -- *** Samples back to back ***
    TestCase <= 1;
    wait until rising_edge(clk_i);
    vld_i   <= '1';
    for sample in 0 to 3 loop
      for channel in 0 to 2 loop
        dat_i <= std_logic_vector(to_unsigned(16#50# + channel * 16#10# + sample, dat_i'length));
        wait until rising_edge(clk_i);
      end loop;
    end loop;
    vld_i   <= '0';

    wait for 100 ns;
    -- *** Input length is 2 (EnabledChannels = ChannelCount_g - 1) ***
    -- *** Samples with much space in between ***
    TestCase        <= 2;
    enabled_channels_i <= channel_count_g - 1;
    wait until rising_edge(clk_i);
    for sample in 0 to 3 loop
      for channel in 0 to 1 loop
        vld_i <= '1';
        dat_i    <= std_logic_vector(to_unsigned(channel * 16#10# + sample, dat_i'length));
        wait until rising_edge(clk_i);
        vld_i <= '0';
        dat_i    <= (others => '0');
        for del in 0 to 9 loop
          wait until rising_edge(clk_i);
        end loop;
      end loop;
    end loop;

    -- *** Samples back to back ***
    TestCase <= 3;
    wait until rising_edge(clk_i);
    vld_i   <= '1';
    for sample in 0 to 3 loop
      for channel in 0 to 1 loop
        dat_i <= std_logic_vector(to_unsigned(16#50# + channel * 16#10# + sample, dat_i'length));
        wait until rising_edge(clk_i);
      end loop;
    end loop;
    vld_i   <= '0';

    wait for 100 ns;
    -- *** Input length is 1 (EnabledChannels = ChannelCount_g - 2) ***
    -- *** Samples with much space in between ***
    TestCase        <= 4;
    enabled_channels_i <= channel_count_g - 2;
    wait until rising_edge(clk_i);
    for sample in 0 to 3 loop
      vld_i <= '1';
      dat_i    <= std_logic_vector(to_unsigned(sample, dat_i'length));
      wait until rising_edge(clk_i);
      vld_i <= '0';
      dat_i    <= (others => '0');
      for del in 0 to 9 loop
        wait until rising_edge(clk_i);
      end loop;
    end loop;

    -- *** Samples back to back ***
    TestCase <= 5;
    wait until rising_edge(clk_i);
    vld_i   <= '1';
    for sample in 0 to 3 loop
      dat_i <= std_logic_vector(to_unsigned(16#50# + sample, dat_i'length));
      wait until rising_edge(clk_i);
    end loop;
    vld_i   <= '0';

    wait for 100 ns;
    -- *** TdmLast test ***
    -- *** max input length (EnabledChannels = ChannelCount_g) ***
    -- *** Samples with much space in between ***
    TestCase        <= 6;
    enabled_channels_i <= channel_count_g;
    wait until rising_edge(clk_i);
    for sample in 0 to 3 loop
      for channel in 0 to 2 loop
        vld_i  <= '1';
        dat_i     <= std_logic_vector(to_unsigned(channel * 16#10# + sample, dat_i'length));
        if channel = 2 then
          last_i <= '1';
        else
          last_i <= '0';
        end if;
        wait until rising_edge(clk_i);
        vld_i  <= '0';
        dat_i     <= (others => '0');
        last_i <= '0';
        for del in 0 to 9 loop
          wait until rising_edge(clk_i);
        end loop;
      end loop;
    end loop;

    -- *** Samples back to back ***
    TestCase <= 7;
    wait until rising_edge(clk_i);
    vld_i   <= '1';
    for sample in 0 to 3 loop
      for channel in 0 to 2 loop
        dat_i <= std_logic_vector(to_unsigned(16#50# + channel * 16#10# + sample, dat_i'length));
        if channel = 2 then
          last_i <= '1';
        else
          last_i <= '0';
        end if;
        wait until rising_edge(clk_i);
      end loop;
    end loop;
    last_i  <= '0';
    vld_i   <= '0';

    wait for 100 ns;
    -- *** Input length is 2 (EnabledChannels = ChannelCount_g - 1) ***
    -- *** Samples with much space in between ***
    TestCase        <= 8;
    enabled_channels_i <= channel_count_g - 1;
    wait until rising_edge(clk_i);
    for sample in 0 to 3 loop
      for channel in 0 to 1 loop
        vld_i  <= '1';
        dat_i     <= std_logic_vector(to_unsigned(channel * 16#10# + sample, dat_i'length));
        if channel = 1 then
          last_i <= '1';
        else
          last_i <= '0';
        end if;
        wait until rising_edge(clk_i);
        vld_i  <= '0';
        dat_i     <= (others => '0');
        last_i <= '0';
        for del in 0 to 9 loop
          wait until rising_edge(clk_i);
        end loop;
      end loop;
    end loop;

    -- *** Samples back to back ***
    TestCase <= 9;
    wait until rising_edge(clk_i);
    vld_i   <= '1';
    for sample in 0 to 3 loop
      for channel in 0 to 1 loop
        dat_i <= std_logic_vector(to_unsigned(16#50# + channel * 16#10# + sample, dat_i'length));
        if channel = 1 then
          last_i <= '1';
        else
          last_i <= '0';
        end if;
        wait until rising_edge(clk_i);
      end loop;
    end loop;
    last_i  <= '0';
    vld_i   <= '0';

    wait for 100 ns;
    -- *** Input length is 1 (EnabledChannels = ChannelCount_g - 2) ***
    -- *** Samples with much space in between ***
    TestCase        <= 10;
    enabled_channels_i <= channel_count_g - 2;
    wait until rising_edge(clk_i);
    for sample in 0 to 3 loop
      vld_i  <= '1';
      dat_i     <= std_logic_vector(to_unsigned(sample, dat_i'length));
      last_i <= '1';
      wait until rising_edge(clk_i);
      vld_i  <= '0';
      dat_i     <= (others => '0');
      last_i <= '0';
      for del in 0 to 9 loop
        wait until rising_edge(clk_i);
      end loop;
    end loop;

    -- *** Samples back to back ***
    TestCase <= 11;
    wait until rising_edge(clk_i);
    vld_i   <= '1';
    for sample in 0 to 3 loop
      dat_i     <= std_logic_vector(to_unsigned(16#50# + sample, dat_i'length));
      last_i <= '1';
      wait until rising_edge(clk_i);
    end loop;
    last_i  <= '0';
    vld_i   <= '0';

    -- end of process !DO NOT EDIT!
    ProcessDone(TbProcNr_inp_c) <= '1';
    wait;
  end process;

  -- *** outp ***
  p_outp : process
  begin
    -- start of process !DO NOT EDIT
    wait until rst_i = '0';

    -- *** Test without TdmLast used ***
    -- *** max input length (EnabledChannels = ChannelCount_g) ***
    -- *** Samples with much space in between ***
    wait until TestCase = 0;
    for sample in 0 to 3 loop
      Expect3Channels((16#00# + sample, 16#10# + sample, 16#20# + sample));
    end loop;

    -- *** Samples back to back ***
    wait until TestCase = 1;
    for sample in 0 to 3 loop
      Expect3Channels((16#50# + sample, 16#60# + sample, 16#70# + sample));
    end loop;

    -- *** Input length is 2 (EnabledChannels = ChannelCount_g - 1) ***
    -- *** Samples with much space in between ***
    wait until TestCase = 2;
    for sample in 0 to 3 loop
      Expect2Channels((16#00# + sample, 16#10# + sample));
    end loop;

    -- *** Samples back to back ***
    wait until TestCase = 3;
    for sample in 0 to 3 loop
      Expect2Channels((16#50# + sample, 16#60# + sample));
    end loop;

    -- *** Input length is 1 (EnabledChannels = ChannelCount_g - 2) ***
    -- *** Samples with much space in between ***
    wait until TestCase = 4;
    for sample in 0 to 3 loop
      Expect1Channel((16#00# + sample));
    end loop;

    -- *** Samples back to back ***
    wait until TestCase = 5;
    for sample in 0 to 3 loop
      Expect1Channel((16#50# + sample));
    end loop;

    -- *** Test using TdmLast ***
    -- *** max input length (EnabledChannels = ChannelCount_g) ***
    -- *** Samples with much space in between ***
    wait until TestCase = 6;
    for sample in 0 to 3 loop
      Expect3Channels((16#00# + sample, 16#10# + sample, 16#20# + sample));
    end loop;

    -- *** Samples back to back ***
    wait until TestCase = 7;
    for sample in 0 to 3 loop
      Expect3Channels((16#50# + sample, 16#60# + sample, 16#70# + sample));
    end loop;

    -- *** Input length is 2 (EnabledChannels = ChannelCount_g - 1) ***
    -- *** Samples with much space in between ***
    wait until TestCase = 8;
    for sample in 0 to 3 loop
      Expect2Channels((16#00# + sample, 16#10# + sample));
    end loop;

    -- *** Samples back to back ***
    wait until TestCase = 9;
    for sample in 0 to 3 loop
      Expect2Channels((16#50# + sample, 16#60# + sample));
    end loop;

    -- *** Input length is 1 (EnabledChannels = ChannelCount_g - 2) ***
    -- *** Samples with much space in between ***
    wait until TestCase = 10;
    for sample in 0 to 3 loop
      Expect1Channel((16#00# + sample));
    end loop;

    -- *** Samples back to back ***
    wait until TestCase = 11;
    for sample in 0 to 3 loop
      Expect1Channel((16#50# + sample));
    end loop;

    -- end of process !DO NOT EDIT!
    ProcessDone(TbProcNr_outp_c) <= '1';
    wait;
  end process;

end;
