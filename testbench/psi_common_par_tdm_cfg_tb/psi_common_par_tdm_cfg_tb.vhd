------------------------------------------------------------------------------
--  Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
--  All rights reserved.
--  Authors: Oliver Bruendler
------------------------------------------------------------------------------

------------------------------------------------------------
-- Testbench generated by TbGen.py
------------------------------------------------------------
-- see Library/Python/TbGenerator

------------------------------------------------------------
-- Libraries
------------------------------------------------------------
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

library work;
	use work.psi_common_math_pkg.all;
	use work.psi_common_logic_pkg.all;
	use work.psi_common_array_pkg.all;
	use work.psi_tb_compare_pkg.all;

------------------------------------------------------------
-- Entity Declaration
------------------------------------------------------------
entity psi_common_par_tdm_cfg_tb is
end entity;

------------------------------------------------------------
-- Architecture
------------------------------------------------------------
architecture sim of psi_common_par_tdm_cfg_tb is
	-- *** Fixed Generics ***
	constant channel_count_g : natural := 3;
	constant channel_width_g : natural := 8;
	
	-- *** Not Assigned Generics (default values) ***
	
	-- *** TB Control ***
	signal TbRunning : boolean := True;
	signal NextCase : integer := -1;
	signal ProcessDone : std_logic_vector(0 to 1) := (others => '0');
	constant AllProcessesDone_c : std_logic_vector(0 to 1) := (others => '1');
	constant TbProcNr_inp_c : integer := 0;
	constant TbProcNr_outp_c : integer := 1;
	
	-- *** DUT Signals ***
	signal clk_i : std_logic := '1';
	signal rst_i : std_logic := '1';
	signal dat_i : std_logic_vector(channel_count_g*channel_width_g-1 downto 0) := (others => '0');
	signal vld_i : std_logic := '0';
	signal enabled_channels_i : integer range 0 to channel_count_g := channel_count_g;
	signal dat_o : std_logic_vector(channel_width_g-1 downto 0) := (others => '0');
	signal last_o : std_logic := '0';
	signal vld_o : std_logic := '0';
	
	-- handwritten
	signal TestCase	: integer := -1;
	signal Channels	: t_aslv8(0 to 2) := (others => (others => '0'));
	
	procedure ExpectChannels(	Values : in t_ainteger(0 to 2)) is
	begin
		wait until rising_edge(clk_i) and vld_o = '1';
		StdlCompare(0, last_o, "Last asserted wrongly channel 0");
		StdlvCompareInt (Values(0), dat_o, "Wrong value Channel 0", false);
		wait until rising_edge(clk_i) and vld_o = '1';
		StdlvCompareInt (Values(1), dat_o, "Wrong value Channel 1", false);
		StdlCompare(0, last_o, "Last asserted wrongly channel 1");
		wait until rising_edge(clk_i) and vld_o = '1';
		StdlvCompareInt (Values(2), dat_o, "Wrong value Channel 2", false);
		StdlCompare(1, last_o, "Last not asserted 2");
	end procedure;
	
begin
	------------------------------------------------------------
	-- DUT Instantiation
	------------------------------------------------------------
	dat_i(channel_width_g*3-1 downto channel_width_g*2) <= Channels(2);
	dat_i(channel_width_g*2-1 downto channel_width_g*1) <= Channels(1);
	dat_i(channel_width_g*1-1 downto channel_width_g*0) <= Channels(0);
	
	i_dut : entity work.psi_common_par_tdm_cfg
		generic map (
			ch_nb_g => channel_count_g,
			ch_width_g => channel_width_g
		)
		port map (
			clk_i => clk_i,
			rst_i => rst_i,
			dat_i => dat_i,
			enabled_ch_i => enabled_channels_i,
			vld_i => vld_i,
			dat_o => dat_o,
			vld_o => vld_o,
			last_o => last_o
		);
	
	------------------------------------------------------------
	-- Testbench Control !DO NOT EDIT!
	------------------------------------------------------------
	p_tb_control : process
	begin
		wait until rst_i = '0';
		wait until ProcessDone = AllProcessesDone_c;
		TbRunning <= false;
		wait;
	end process;
	
	------------------------------------------------------------
	-- Clocks !DO NOT EDIT!
	------------------------------------------------------------
	p_clock_Clk : process
		constant Frequency_c : real := real(100e6);
	begin
		while TbRunning loop
			wait for 0.5*(1 sec)/Frequency_c;
			clk_i <= not clk_i;
		end loop;
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Resets
	------------------------------------------------------------
	p_rst_Rst : process
	begin
		wait for 1 us;
		-- Wait for two clk edges to ensure reset is active for at least one edge
		wait until rising_edge(clk_i);
		wait until rising_edge(clk_i);
		rst_i <= '0';
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Processes
	------------------------------------------------------------
	-- *** inp ***
	p_inp : process
	begin
		-- start of process !DO NOT EDIT
		wait until rst_i = '0';
		
		-- *** Samples with much space in between ***
		TestCase <= 0;
		-- First Sample
		wait until rising_edge(clk_i);
		Channels(0) <= X"01";
		Channels(1) <= X"11";
		Channels(2) <= X"21";
		vld_i <= '1';
		wait until rising_edge(clk_i);
		vld_i <= '0';
		Channels <= (others => (others => '0'));
		wait for 1 us;
		
		-- Second Sample
		wait until rising_edge(clk_i);
		Channels(0) <= X"02";
		Channels(1) <= X"12";
		Channels(2) <= X"22";	
		vld_i <= '1';
		wait until rising_edge(clk_i);	
		vld_i <= '0';
		Channels <= (others => (others => '0'));	
		wait for 1 us;

		-- *** Samples at maximum rate ***
		TestCase <= 1;
		for i in 0 to 5 loop
			wait until rising_edge(clk_i);
			Channels(0) <= std_logic_vector(to_unsigned(16#50# + i, channel_width_g));
			Channels(1) <= std_logic_vector(to_unsigned(16#60# + i, channel_width_g));
			Channels(2) <= std_logic_vector(to_unsigned(16#70# + i, channel_width_g));	
			vld_i <= '1';
			wait until rising_edge(clk_i);
			vld_i <= '0';
			Channels <= (others => (others => '0'));
			wait until rising_edge(clk_i);
		end loop;
		wait for 1 us;
		
		-- *** Do less channels that maximum ***
		TestCase <= 2;
		wait until rising_edge(clk_i);
		Channels(0) <= std_logic_vector(to_unsigned(16#0A#, channel_width_g));
		Channels(1) <= std_logic_vector(to_unsigned(16#0B#, channel_width_g));
		Channels(2) <= std_logic_vector(to_unsigned(16#0C#, channel_width_g));
		enabled_channels_i	<= 2;
		vld_i <= '1';
		wait until rising_edge(clk_i);
		vld_i <= '0';
		Channels <= (others => (others => '0'));
		wait until rising_edge(clk_i);
		wait until rising_edge(clk_i);
		wait until rising_edge(clk_i);
		Channels(0) <= std_logic_vector(to_unsigned(16#0D#, channel_width_g));
		Channels(1) <= std_logic_vector(to_unsigned(16#0E#, channel_width_g));
		Channels(2) <= std_logic_vector(to_unsigned(16#0F#, channel_width_g));
		enabled_channels_i	<= 1;
		vld_i <= '1';
		wait until rising_edge(clk_i);
		vld_i <= '0';
		Channels <= (others => (others => '0'));
		wait until rising_edge(clk_i);
		
			
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_inp_c) <= '1';
		wait;
	end process;
	
	-- *** outp ***
	p_outp : process
	begin
		-- start of process !DO NOT EDIT
		wait until rst_i = '0';
		
		-- *** Samples with much space in between ***
		wait until TestCase = 0;
		-- First Sample
		ExpectChannels((16#01#, 16#11#, 16#21#));
		-- Second Sample
		ExpectChannels((16#02#, 16#12#, 16#22#));
		
		-- *** Samples at maximum rate ***
		wait until TestCase = 1;
		for i in 0 to 5 loop
			ExpectChannels((16#50#+i, 16#60#+i, 16#70#+i));
		end loop;
		
		-- *** Do less channels that maximum ***
		wait until TestCase = 2;
		wait until rising_edge(clk_i) and vld_o = '1';
		StdlCompare(0, last_o, "Last asserted wrongly channel 0");
		StdlvCompareInt (16#0A#, dat_o, "Wrong value Channel 0", false);
		wait until rising_edge(clk_i) and vld_o = '1';
		StdlvCompareInt (16#0B#, dat_o, "Wrong value Channel 1", false);
		StdlCompare(1, last_o, "Last not asserted 1");
		wait until rising_edge(clk_i);
		StdlCompare(0, vld_o, "vld_o not de-asserted");
		
		wait until rising_edge(clk_i) and vld_o = '1';
		StdlvCompareInt (16#0D#, dat_o, "Wrong value Channel 0", false);
		StdlCompare(1, last_o, "Last not asserted 0");
		wait until rising_edge(clk_i);
		StdlCompare(0, vld_o, "vld_o not de-asserted");
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_outp_c) <= '1';
		wait;
	end process;
	
	
end;
